# 关于《为什么选择b+树作为存储引擎索引结构》的几点建议 #
*申明：本文仅为个人学习笔记，目的是大家一起讨论和学习进步，不代表对原文、原文作者或作者公司等有任何负面看法。原文是非常好的分享，为学习者提供很多资料和学习思路。本文由于作者水平有限，文中难免有错漏或不足，欢迎大家一起交流学习。*

## 文字表达有歧义的地方 ##
### 原文1.4采用性价比高的存储-第7段 ###
> 普通的机械硬盘读写数据主要是通过移动磁头到对应的磁道，然后**再旋转磁头到**对应的扇区。最后进行移动磁头进行读写数据。

易让人误解是说磁头在旋转，但是其实磁头是不能旋转的，所有磁头由一个磁臂相连，只能在磁盘的半径方向上移动，而旋转的是磁盘。估计原文是想表达“然后再旋转 **待** 磁头到对应扇区”或者笔误“然后再旋转磁 **盘** 到对应的扇区”写成了“然后再旋转磁 **头** 到对应的扇区”，所以这里修改为“然后待磁盘旋转到磁头对应的扇区”应该更加清晰。
## 文档论述或逻辑问题 ##
### 索引存在的原因是记录是变长的 ###

1、原文3.3第三段
> 每条记录长度各不相同，既然要保证读，那就得额外保存一些信息来辅助处理用户的读请求。这些额外保存的数据，我们暂且称为索引。

2、原文3.4索引矛盾点的第一段
> 索引核心矛盾点: 根据前面的分析，每条记录是变长的，所以需要每条记录都维护一个索引项。

   这个说法是不够严谨，索引的存在是为了高效查找文件或数据库中的特定键的值，否则，当查找一个记录的时候就必须从头到尾扫描整个数据文件。而跟记录的定长还是变长没有直接关系，而记录是定长还是变长，只在记录在块中表示和组织、记录的索引项内容压缩（文中有提到）方面有关系。
   这一点在《数据密集型系统设计》中的论述和引出“索引”的逻辑就说的比较清楚，“索引背后的大致思想是，保存一些额外的元数据作为路标，帮助你找到想要的数据。”具体内容请参考该书第一部分：数据系统的基石。第三章：存储与检索-哈希索引。

### 原文3.3直观思路出发-第三、四、五、六段 ###

### 第三段 ###
> 根据前面的介绍，数据是按照 key-value 来扁平化存储的。每条记录长度各不相同，既然要保证读，那就得额外保存一些信息来辅助处理用户的读请求。这些额外保存的数据，我们暂且称为索引。我们思索一下，在这种追加写的场景下，我们需要保存哪些信息才可以完成正常的读请求呢？其实每条记录我们只要知道了它写在磁盘的哪个位置(偏移量)offset、占了多长 size 这两个信息。我们就可以对其进行读了。简而言之，一条记录对应一个这样的二元组索引信息。简单示意图如下所以：

1、第一处 
> 数据是按照key-value来**扁平化**存储的。

如何理解扁平化存储，这是一个不清晰的表达，如果是要假设将key-value键值对数据按日志机构方式仅做追加写的方式，可以参考《数据密集型应用系统设计》p75左右的如下描述。
> 底层的存储格式非常简单：一个文本文件，每行包含一条逗号分隔的键值对（忽略转义问题的话，大致与CSV文件类似）。


2、第二处
> 其实每条记录我们只要知道了它写在磁盘的哪个位置(偏移量)offset、占了多长 size 这两个信息。我们就可以对其进行读了。
 
按文中假设成立的话，其实索引只需要两个信息，即key（record1，record2...），offset，是得不出文中结论需要offset、和size两个数据的，这里不知道怎么推出来的。因为记录是追加写的方式存在文件中，也就是说是**连续**的。这部分内容可以参考《数据密集型应用系统设计》p76
图3-1


### 第四段 ###

> 在这种场景下，每来一条记录我们都是直接追加的，所以数据在磁盘上本身就是乱序存储的，既然需要排序、范围查找的话。那就得把磁盘上的所有记录都加载到内存中，然后再挨个挨个遍历判断，最后过滤出来满足条件的记录返回用户。这种方式能实现功能，但显然效率太低了。同时磁盘上存储的数据可能都远远超过内存大小了，所以这种方式根本就不可取。那有没有办法解决该问题呢？

### 第五段 ###

> 我们做一点假设：**假设我们写磁盘的时候能保证顺序写的同时，写入的数据是有序的。**比如，我们写入了三条数据，这三条数据本身写入的时候是排好序的，那么此时范围查找时，我们只要定位到第一条数据，后面的数据是有序的，就可以很快进行按序读取了。如果假设条件成立的话，那排序、范围查找这个问题就从根本上得到简化了。我们也就不用这么大费周折了。我们先基于这个简单假设来看一下，在假设条件成立的情况下，我们还需要解决哪些问题呢？


1、第一处
>  假设写磁盘的时候能保证顺序写的同时，写入的数据是有序的。

这个假设比较跳跃，既然是顺序写，即追加写，说白了就是来了就往后加，这种情况下写入的数据怎么会是有序的？具体分析如下。

第一，必然会令人提出疑问，按什么有序，怎么实现有序的？因为这里是追加写即顺序写，也就是来了就往后面加。这种情况下，写入的数据本身是无序的，而且并没有一个提前的排序过程，也没有一种排序的结构来保证写入后有序。第二，这里假设写入时数据是有序的，是为了推出后面的何种结论？为了该结论，该假设是否是一个合理的假设。

   再从第五段后续内容看，如果要使起始句的假设有意义，这里像是说的索引文件（索引文件保存在磁盘上）的写入，那第五段内容讲得通，因为索引（顺序索引）本身是按照搜索码排序的，而且可以实现后面说的范围查找。但是依据第四段及以前论述又像是写数据记录本身的，如果是数据记录本身，要写入有序又跟前面顺序写的假设冲突，到底是索引记录还是数据记录本身这里没有明确。
   根据后续3.4节相关内容推断出，这里讲的都是索引记录在磁盘块中的存储。

2、第二处
> - 这三条数据本身写入的时候是排好序的，那么此时范围查找时，我们只要定位到第一条数据，后面的数据是有序的，就可以很快进行按序读取了。

由于有了上面的假设，很容易得到这个结论。我们先不考虑上面的假设是否有问题的情况下来分析。在有序结构上做范围查找或顺序读取，看这个描述应该是在一个索引文件上搜索，因为如果是数据记录在文件中的组织，除非是顺序文件（sequential file），其他形式很难实现按序读取。其实在文中把记录本身和索引分开来说比较清晰（尽管索引本身也是一种记录）。


### 第六段 ###

> 在这种模式下，我们访问每条记录同时还是需要保留之前的结论：每条数据都维护一个索引项：offset、size。
 

### 3.4索引矛盾点 ###
### 第三段 ###
> 将磁盘划分成一个一个的固定大小连续块后，每个块内仍然保留原先过程中的两大特性：数据有序并且顺序写
 
类似上面3.3节第五段做数据有序并顺序写的假设存在的问题（按什么有序？如何有序？为什么要有序）。进一步这里引入了“**块**”，在原来基础上假设变成了，**每个块内仍然保留原先过程中的两大特性：数据有序并且顺序写**，而块内数据保证有序是完全的另一个话题（注2），并且一般说顺序写也不会说或者指块（内），一般指文件。这里把文件这个概念替换到了块上，前面的内容可以认为是说一个个文件。

### 第六段 ###

> 正常情况下，我们的一个块会保存多条记录，并且块内的记录是有序存储的。我们在读取一条记录的时候，一条记录肯定是位于其中一块上，首先我们得解决这个定位问题。当定位到具体的块后，将当前块的数据从磁盘加载到内存中，块内部的数据是有序存储的，那自然就可以通过二分的方式来找到我们的具体数据对应的索引项了。最后再根据索引项来读取数据即可。同理写的过程虽然对外来看是对单条记录进行写，但内部是按照块作为单位来写磁盘。

- 块内部的数据是有序存储的，那自然就可以通过二分的方式来找到我们的具体数据对应的**索引项**了。
  从这里判定，刚才（上面3.3节）说的记录都是指的索引记录，在说索引文件。
## 其他建议 ##
文章的逻辑结构推进上，《数据密集型应用系统设计》就很值得参考。

- 最简单的数据库的数据存取——>log结构数据的追加写
- 读取记录需要索引——>最简单最直接的索引结构：内存中的哈希索引
- 如何防止磁盘空间用完——>分段、压缩、SSTable
- 优化压缩和文件管理——>键值对按键排序、每个键在每个合并的段文件中只出现一次。注1
- how:在内存中找到树形结构，当其大于某阈值时写入磁盘。

又例如《数据库系统内幕》

- 二分搜索树（BST）——>树的平衡和查找时间复杂度
- 磁盘上实现需要 ———>高扇出、低高度
- B树、B+树 ——>B树和B+树的差别以及操作

这两处的文章的章节和逻辑段落的推进逻辑清晰，假设和猜想要合理，在描述某一个问题时不添加进解决其他问题的前提。这样更方便大家快速理解，并且串联起已有的知识点。

[原文链接1](https://cloud.tencent.com/developer/article/1831560)
[原文链接2](https://blog.csdn.net/Tencent_TEG/article/details/117828676)

注1：why这里要这样要求也说清楚了：为了使用sort-merge排序而且不需要所有键都存到内存。

注2：这部分内容可以参考《数据库系统内幕》中文版P49，3.3-3.8相关章节
《数据库系统概念》第六版中文版P255，英文版450-458,10.5-10.6相关章节
